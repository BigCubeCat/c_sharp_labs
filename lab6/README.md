1. Общая архитектура

Лабораторная работа реализует задачу «обедающих философов» в виде распределённой системы:

каждый философ — отдельный ASP.NET Core-сервис;

управление ресурсами (вилки, регистрация, завершение симуляции) — отдельный сервис SimulationManager;

взаимодействие между сервисами осуществляется по HTTP;

внутри каждого сервиса используется асинхронное взаимодействие через Channel.

Контейнеризация выполнена через Docker Compose.

2. Уровни взаимодействия
2.1. Межсервисное взаимодействие (HTTP)

Используются DTO из DataContracts, что жёстко фиксирует контракт.

Основные направления:

Философ → SimulationManager

регистрация философа (POST /register-me);

операции с вилками (POST /lock-or-take-fork, POST /put-or-unlock-fork).

SimulationManager → философ

опрос состояния (GET /Philosopher);

опрос действий (GET /Philosopher/action);

остановка (GET /Philosopher/stop).

Все философы получают HOST_URI через переменные окружения и работают без знания конкретной реализации менеджера.

3. Взаимодействие внутри философа
3.1. Фоновая логика (BackgroundService)

Класс PhilosopherService:

реализует машину состояний (Thinking → Hungry → TakeFork → Eating);

запускается как HostedService;

не взаимодействует с HTTP напрямую.

3.2. Каналы как механизм связи

Для связи между:

Controller (HTTP слой),

PhilosopherService (бизнес-логика)

используется абстракция:

IChannel<T>


На практике это обёртка над System.Threading.Channels.

Используемые каналы:

PhilosopherToControllerChannelItem — информация и статистика;

PhilosopherActionItem — текущее действие (ест / не ест);

ApplicationStopItem — сигнал завершения.

3.3. Сценарий запроса данных

Пример: GET /Philosopher

Controller вызывает:

_channel.Notify(this);


PhilosopherService подписан на событие SendMeItem.

Сервис формирует данные и пишет их в ChannelWriter.

Controller читает ответ через:

await _channel.Reader.ReadAsync();


Таким образом:

Controller не знает, как формируются данные;

Service не знает, кто именно их запросил.

Это слабосвязанная, событийно-канальная модель.

4. Управление вилками
4.1. Вилки — удалённый ресурс

IFork реализован как ForkService, который:

не хранит состояние локально;

отправляет команды менеджеру по HTTP.

Команды описаны через:

ForkCommandsDto

ForkCommandWithIdDto

4.2. Стратегия захвата

Интерфейс:

IStrategy


Реализация:

LeftRightStrategy


Особенности:

стратегия выбирает порядок захвата вилок;

параметр IsLeftHanded задаётся через конфигурацию;

позволяет избежать дедлоков.

PhilosopherService не содержит логики синхронизации — она вынесена в стратегию.

5. SimulationManager
5.1. Роль менеджера

SimulationManager:

регистрирует философов;

назначает им вилки;

принимает команды блокировки / взятия вилок;

анализирует дедлоки;

управляет временем симуляции.

5.2. Внутренние HostedService

SimulationManager — основной цикл симуляции;

Waiter — координация завершения;

DeadlockAnalyzer — анализ зависаний.

Связь между ними также построена через IChannel<T>.

6. Итоговая схема взаимодействия
HTTP
┌────────────┐        ┌──────────────────┐
│ Philosopher│ <────> │ SimulationManager│
└────────────┘        └──────────────────┘
      │
      │ Channels
      ▼
┌─────────────────────┐
│ PhilosopherService  │
│ (BackgroundService) │
└─────────────────────┘

7. Ключевые архитектурные идеи

Чёткое разделение:

HTTP слой

бизнес-логика

коммуникация

Использование Channel вместо прямых вызовов

Контракты вынесены в отдельные проекты

Горизонтальное масштабирование философов

Отсутствие shared state между сервисами
